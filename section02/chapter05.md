<<<<<<< HEAD
### Spread 연산자 & Rest 매개변수

- Spread 연산자
  - 흩뿌리다, 펼치다 라는 뜻
  - 객체나 배열에 저장된 여러개의 값을 개별로 흩뿌려주는 역할

```jsx
let arr1 = [1, 2, 3];
let arr2 = [4, ...arr1, 5, 6];

// 결과 [4,1,2,3,5,6]
// 저장 된 값을 개별로 흩뿌려줌
```

- … 배열로 사용 가능

- Rest 매개변수
  - Rest는 한번에 모든 매개변수를 받아 올 수 있음

```jsx
function funcB(one, ...rest) {
  //모든 매개변수를 한번에 저장함 - one 같이 따로 매개변수를 Rest에서 뺄 수 있음, 근데 뒤에는 쓰면 안됨
  console.log(rest);
}

funcB(...arr1);
// funcB에 arr1의 값을 한번에 전달해줄 수 있음
```

### 원시 타입 , 객체 타입

- ## 원시 타입
  ```jsx
  let p1 = 1;
  let p2 = p1;
  let p2 = 2;
  ```
  p1 → 1 저장
  p2 → 1 : 메모리 공간에 저장된 값은 수정되지 않음
  1을 가르키지 않고 : p2 → 2
  원시 타입 = 불변값이라고도 함 : 실제 메모리 값은 수정되지 않기 때문에
- 객체 타입

  - 얕은 복사 : 원본 객체가 수정 될 수 있어서 위험함.

  ```jsx
  let o1 = { name: "김민주" };
  let o2 = o1; //o2 복사

  o2.name = "홍길동";
  ```

  o1 → 참조값 저장 (0x0000c) → {name: “김민주”}
  o2 → 참조값 저장 (0x0000c) → {name: “홍길동”}
  : 원시타입 처럼 새로운 값을 만들어 가르키는 것이 아니고, 메모리상에서 값이 아예 수정됨.
  = 가변값 이라고도 함
  객체 값은 의도치 않게 값이 변경될 수도 있다.
  side effect : 의도하지 않았는데 하나의 변화가 또 다른 변수의 변화를 가져오는 것

  - 깊은 복사 : 원본 객체가 수정될 일이 없어 안전함.

  ```jsx
  let o1 = { name: "김민주" };
  let o2 = { ...o1 }; // 내부 프로퍼티만 따로 복사하는 방법을 사용해야함
  ```

  o1 → 참조값 저장 (0x0000c)
  o2 → 참조값 저장 (0x0000d) 이런식으로 됨

  - 객체 간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
    얕은 복사 : 참조값까지 모두 같은 경우
    → if(o1 == o2) → true
    깊은 복사 : 참조값은 다르지만 프로퍼티 값은 같은 경우
    → if(o1 == o3) → false
  - 객체의 비교를 프로퍼티 기준으로 비교할 때
    - JSON.stringify() : 자바스크립트 내장 함수 사용
    ```jsx
    console.log(JSON.stringify(o1) === JSON.stringify(o3));
    ```
    → 객체를 문자열로 변환하는 기능
  - 얕은 비교 , 깊은 비교

    - 얕은 비교 : 참조값을 기준으로 비교
    - 깊은 비교 : 객체를 문자열로 변환하여 비교 - 내장 함수를 이용해야 함

  - 배열과 함수도 사실 객체이다.
    배열과 함수도 일반 객체에 존재하는 프로퍼티와 메서드를 다 가지고 있다.
=======
### Spread 연산자 & Rest 매개변수

- Spread 연산자
    - 흩뿌리다, 펼치다 라는 뜻
    - 객체나 배열에 저장된 여러개의 값을 개별로 흩뿌려주는 역할

```jsx
let arr1 = [1,2,3];
let arr2 = [4, ...arr1, 5, 6];

// 결과 [4,1,2,3,5,6]
// 저장 된 값을 개별로 흩뿌려줌 
```

- … 배열로 사용 가능

- Rest 매개변수
    - Rest는 한번에 모든 매개변수를 받아 올 수 있음

```jsx
function funcB(one,...rest) { //모든 매개변수를 한번에 저장함 - one 같이 따로 매개변수를 Rest에서 뺄 수 있음, 근데 뒤에는 쓰면 안됨
	console.log(rest);
}

funcB(...arr1); 
// funcB에 arr1의 값을 한번에 전달해줄 수 있음 
```

### 원시 타입 , 객체 타입

- 원시 타입
    - 
    
    ```jsx
    let p1 = 1;
    let p2 = p1;
    let p2 = 2;
    ```
    
    p1 → 1 저장
    
    p2 → 1 : 메모리 공간에 저장된 값은 수정되지 않음
    
    1을 가르키지 않고 : p2 → 2
    
    원시 타입 = 불변값이라고도 함 : 실제 메모리 값은 수정되지 않기 때문에 
    
- 객체 타입
    - 얕은 복사 : 원본 객체가 수정 될 수 있어서 위험함.
    
    ```jsx
    let o1 = { name: "김민주" };
    let o2 = o1; //o2 복사
    
    o2.name = "홍길동";
    ```
    
    o1 → 참조값 저장 (0x0000c) → {name: “김민주”}
    
    o2 → 참조값 저장 (0x0000c) → {name: “홍길동”}
    
    : 원시타입 처럼 새로운 값을 만들어 가르키는 것이 아니고, 메모리상에서 값이 아예 수정됨. 
    
    = 가변값 이라고도 함
    
    객체 값은 의도치 않게 값이 변경될 수도 있다. 
    
    side effect : 의도하지 않았는데 하나의 변화가 또 다른 변수의 변화를 가져오는 것
    
    - 깊은 복사 : 원본 객체가 수정될 일이 없어 안전함.
    
    ```jsx
    let o1 = { name : "김민주"};
    let o2 = {...o1}; // 내부 프로퍼티만 따로 복사하는 방법을 사용해야함 
    ```
    
    o1 → 참조값 저장 (0x0000c)
    
    o2 → 참조값 저장 (0x0000d) 이런식으로 됨
    
    - 객체 간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
        
        얕은 복사 : 참조값까지 모두 같은 경우 
        
        → if(o1 == o2) → true 
        
        깊은 복사 : 참조값은 다르지만 프로퍼티 값은 같은 경우
        
        → if(o1 == o3) → false
        
    - 객체의 비교를 프로퍼티 기준으로 비교할 때
        - JSON.stringify() : 자바스크립트 내장 함수 사용
        
        ```jsx
        console.log(
        	JSON.stringify(o1) === JSON.stringify(o3)
        );
        ```
        
        → 객체를 문자열로 변환하는 기능 
        
    - 얕은 비교 , 깊은 비교
        - 얕은 비교 : 참조값을 기준으로 비교
        - 깊은 비교 : 객체를 문자열로 변환하여 비교 - 내장 함수를 이용해야 함
    
    - 배열과 함수도 사실 객체이다.
        
        배열과 함수도 일반 객체에 존재하는 프로퍼티와 메서드를 다 가지고 있다.
>>>>>>> f33ba9bf042945760d6170378d334c8147fec91e
